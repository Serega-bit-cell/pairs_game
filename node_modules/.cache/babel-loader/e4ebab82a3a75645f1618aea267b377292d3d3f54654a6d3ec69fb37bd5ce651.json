{"ast":null,"code":"import { SELECT_TILE, RESET_GAME } from './actions';\nconst initialState = {\n  tiles: Array.from({\n    length: 16\n  }, (_, index) => ({\n    id: index,\n    isOpen: false,\n    color: Math.floor(index / 2) // Упрощенная логика для создания пар\n  })),\n  firstSelected: null,\n  secondSelected: null\n};\nconst reducer = (state = initialState, action) => {\n  switch (action.type) {\n    case SELECT_TILE:\n      const selectedTile = state.tiles.find(tile => tile.id === action.payload);\n\n      // Проверяем, есть ли уже первая или вторая выбранная плитка\n      if (!state.firstSelected) {\n        return {\n          ...state,\n          firstSelected: selectedTile,\n          tiles: state.tiles.map(tile => tile.id === selectedTile.id ? {\n            ...tile,\n            isOpen: true\n          } : tile)\n        };\n      } else if (!state.secondSelected && state.firstSelected.id !== selectedTile.id) {\n        // Если выбрана вторая плитка и она не равна первой\n        return {\n          ...state,\n          secondSelected: selectedTile,\n          tiles: state.tiles.map(tile => tile.id === selectedTile.id ? {\n            ...tile,\n            isOpen: true\n          } : tile)\n        };\n      }\n\n      // Если выбраны обе плитки\n      if (state.firstSelected && state.secondSelected) {\n        // Сравниваем цвета\n        const isMatch = state.firstSelected.color === state.secondSelected.color;\n\n        // Обновляем плитки в зависимости от совпадения\n        const updatedTiles = state.tiles.map(tile => {\n          if (tile.id === state.firstSelected.id || tile.id === state.secondSelected.id) {\n            return isMatch ? {\n              ...tile,\n              isOpen: true\n            } : {\n              ...tile,\n              isOpen: false\n            };\n          }\n          return tile;\n        });\n        return {\n          ...state,\n          tiles: updatedTiles,\n          firstSelected: isMatch ? null : state.firstSelected,\n          secondSelected: null\n        };\n      }\n      return state;\n    case RESET_GAME:\n      return initialState;\n    default:\n      return state;\n  }\n};\nexport default reducer;","map":{"version":3,"names":["SELECT_TILE","RESET_GAME","initialState","tiles","Array","from","length","_","index","id","isOpen","color","Math","floor","firstSelected","secondSelected","reducer","state","action","type","selectedTile","find","tile","payload","map","isMatch","updatedTiles"],"sources":["/Users/sergej/pairs-game/src/redux/reducer.js"],"sourcesContent":["import { SELECT_TILE, RESET_GAME } from './actions';\n\nconst initialState = {\n    tiles: Array.from({ length: 16 }, (_, index) => ({\n        id: index,\n        isOpen: false,\n        color: Math.floor(index / 2) // Упрощенная логика для создания пар\n    })),\n    firstSelected: null,\n    secondSelected: null,\n};\n\nconst reducer = (state = initialState, action) => {\n    switch (action.type) {\n        case SELECT_TILE:\n            const selectedTile = state.tiles.find(tile => tile.id === action.payload);\n\n            // Проверяем, есть ли уже первая или вторая выбранная плитка\n            if (!state.firstSelected) {\n                return {\n                    ...state,\n                    firstSelected: selectedTile,\n                    tiles: state.tiles.map(tile =>\n                        tile.id === selectedTile.id ? { ...tile, isOpen: true } : tile\n                    ),\n                };\n            } else if (!state.secondSelected && state.firstSelected.id !== selectedTile.id) {\n                // Если выбрана вторая плитка и она не равна первой\n                return {\n                    ...state,\n                    secondSelected: selectedTile,\n                    tiles: state.tiles.map(tile =>\n                        tile.id === selectedTile.id ? { ...tile, isOpen: true } : tile\n                    ),\n                };\n            }\n\n            // Если выбраны обе плитки\n            if (state.firstSelected && state.secondSelected) {\n                // Сравниваем цвета\n                const isMatch = state.firstSelected.color === state.secondSelected.color;\n\n                // Обновляем плитки в зависимости от совпадения\n                const updatedTiles = state.tiles.map(tile => {\n                    if (tile.id === state.firstSelected.id || tile.id === state.secondSelected.id) {\n                        return isMatch ? { ...tile, isOpen: true } : { ...tile, isOpen: false };\n                    }\n                    return tile;\n                });\n\n                return {\n                    ...state,\n                    tiles: updatedTiles,\n                    firstSelected: isMatch ? null : state.firstSelected,\n                    secondSelected: null,\n                };\n            }\n\n            return state;\n\n        case RESET_GAME:\n            return initialState;\n\n        default:\n            return state;\n    }\n};\n\nexport default reducer;"],"mappings":"AAAA,SAASA,WAAW,EAAEC,UAAU,QAAQ,WAAW;AAEnD,MAAMC,YAAY,GAAG;EACjBC,KAAK,EAAEC,KAAK,CAACC,IAAI,CAAC;IAAEC,MAAM,EAAE;EAAG,CAAC,EAAE,CAACC,CAAC,EAAEC,KAAK,MAAM;IAC7CC,EAAE,EAAED,KAAK;IACTE,MAAM,EAAE,KAAK;IACbC,KAAK,EAAEC,IAAI,CAACC,KAAK,CAACL,KAAK,GAAG,CAAC,CAAC,CAAC;EACjC,CAAC,CAAC,CAAC;EACHM,aAAa,EAAE,IAAI;EACnBC,cAAc,EAAE;AACpB,CAAC;AAED,MAAMC,OAAO,GAAGA,CAACC,KAAK,GAAGf,YAAY,EAAEgB,MAAM,KAAK;EAC9C,QAAQA,MAAM,CAACC,IAAI;IACf,KAAKnB,WAAW;MACZ,MAAMoB,YAAY,GAAGH,KAAK,CAACd,KAAK,CAACkB,IAAI,CAACC,IAAI,IAAIA,IAAI,CAACb,EAAE,KAAKS,MAAM,CAACK,OAAO,CAAC;;MAEzE;MACA,IAAI,CAACN,KAAK,CAACH,aAAa,EAAE;QACtB,OAAO;UACH,GAAGG,KAAK;UACRH,aAAa,EAAEM,YAAY;UAC3BjB,KAAK,EAAEc,KAAK,CAACd,KAAK,CAACqB,GAAG,CAACF,IAAI,IACvBA,IAAI,CAACb,EAAE,KAAKW,YAAY,CAACX,EAAE,GAAG;YAAE,GAAGa,IAAI;YAAEZ,MAAM,EAAE;UAAK,CAAC,GAAGY,IAC9D;QACJ,CAAC;MACL,CAAC,MAAM,IAAI,CAACL,KAAK,CAACF,cAAc,IAAIE,KAAK,CAACH,aAAa,CAACL,EAAE,KAAKW,YAAY,CAACX,EAAE,EAAE;QAC5E;QACA,OAAO;UACH,GAAGQ,KAAK;UACRF,cAAc,EAAEK,YAAY;UAC5BjB,KAAK,EAAEc,KAAK,CAACd,KAAK,CAACqB,GAAG,CAACF,IAAI,IACvBA,IAAI,CAACb,EAAE,KAAKW,YAAY,CAACX,EAAE,GAAG;YAAE,GAAGa,IAAI;YAAEZ,MAAM,EAAE;UAAK,CAAC,GAAGY,IAC9D;QACJ,CAAC;MACL;;MAEA;MACA,IAAIL,KAAK,CAACH,aAAa,IAAIG,KAAK,CAACF,cAAc,EAAE;QAC7C;QACA,MAAMU,OAAO,GAAGR,KAAK,CAACH,aAAa,CAACH,KAAK,KAAKM,KAAK,CAACF,cAAc,CAACJ,KAAK;;QAExE;QACA,MAAMe,YAAY,GAAGT,KAAK,CAACd,KAAK,CAACqB,GAAG,CAACF,IAAI,IAAI;UACzC,IAAIA,IAAI,CAACb,EAAE,KAAKQ,KAAK,CAACH,aAAa,CAACL,EAAE,IAAIa,IAAI,CAACb,EAAE,KAAKQ,KAAK,CAACF,cAAc,CAACN,EAAE,EAAE;YAC3E,OAAOgB,OAAO,GAAG;cAAE,GAAGH,IAAI;cAAEZ,MAAM,EAAE;YAAK,CAAC,GAAG;cAAE,GAAGY,IAAI;cAAEZ,MAAM,EAAE;YAAM,CAAC;UAC3E;UACA,OAAOY,IAAI;QACf,CAAC,CAAC;QAEF,OAAO;UACH,GAAGL,KAAK;UACRd,KAAK,EAAEuB,YAAY;UACnBZ,aAAa,EAAEW,OAAO,GAAG,IAAI,GAAGR,KAAK,CAACH,aAAa;UACnDC,cAAc,EAAE;QACpB,CAAC;MACL;MAEA,OAAOE,KAAK;IAEhB,KAAKhB,UAAU;MACX,OAAOC,YAAY;IAEvB;MACI,OAAOe,KAAK;EACpB;AACJ,CAAC;AAED,eAAeD,OAAO","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}